import Mathlib.Analysis.Complex.UpperHalfPlane.Basic
import Mathlib.NumberTheory.ModularForms.Basic
import Mathlib.NumberTheory.ModularForms.CongruenceSubgroups
import Mathlib.NumberTheory.ModularForms.SlashInvariantForms
import Mathlib

/-!
# Auxiliary theorems for the slash actions groups SL(2, ℤ) and Γ(2)

Define special generators S, T, -I (resp. α, β, -I) for SL(2,ℤ) (resp. Γ(2)) and prove that
they are indeed generators.
As a corollary, we only need to check the invariance under these special elements to check
the invariance under the whole group.
These theorems will be used to prove that 4-th powers of Jacobi theta functions Θ_2^4, Θ_3^4, Θ_4^4
are modular forms of weight 2 and level Γ(2).
-/

open scoped  ModularForm MatrixGroups
open Matrix UpperHalfPlane CongruenceSubgroup ModularGroup

local notation "GL(" n ", " R ")" "⁺" => Matrix.GLPos (Fin n) R
local notation "Γ " n:100 => Gamma n

/- This part defines generators of Γ 2 and some relations between them. -/

def α : Γ 2 := ⟨⟨!![1, 2; 0, 1], by simp⟩, by simp; decide⟩
def β : Γ 2 := ⟨⟨!![1, 0; 2, 1], by simp⟩, by simp; decide⟩
def negI : Γ 2 := ⟨⟨!![-1, 0; 0, -1], by simp⟩, by simp⟩

theorem α_eq_T_sq : α = ⟨T ^ 2,  by simp [sq, T]; decide⟩ := by
  ext
  simp [α, T, sq]

theorem β_eq_negI_mul_S_mul_α_inv_mul_S : β = negI * S * α⁻¹ * S := by
  ext
  simp [β, S, α, negI]

theorem ModularGroup.modular_negI_sq : negI ^ 2 = 1 := by
  ext i j
  simp [negI, sq]
  fin_cases i <;> fin_cases j <;> rfl

theorem ModularGroup.modular_negI_inv : negI⁻¹ = negI := by
  ext i j
  simp [negI]

section slash_action

variable (f : ℍ → ℂ) (k : ℤ) (z : ℍ)

open ModularForm

/- This section proves rewriting lemmas for f|[k]γ for various γ. -/

theorem modular_negI_smul : negI.1 • z = z := by
  rw [specialLinearGroup_apply]
  simp [negI, num, denom]

theorem modular_slash_negI_of_even (hk : Even k) : f ∣[k] negI.1 = f := by
  ext x
  rw [slash_action_eq'_iff]
  rw [modular_negI_smul]
  simp only [negI, Int.reduceNeg, Fin.isValue, of_apply, cons_val', cons_val_zero, empty_val',
    cons_val_fin_one, cons_val_one, head_fin_const, Int.cast_zero, zero_mul, head_cons,
    Int.cast_neg, Int.cast_one, zero_add, hk.neg_one_zpow, one_mul]

theorem modular_slash_S_apply :
    (f ∣[k] S) z = f (UpperHalfPlane.mk (-z)⁻¹ z.im_inv_neg_coe_pos) * z ^ (-k) := by
  rw [SL_slash_apply, denom, UpperHalfPlane.modular_S_smul]
  simp [S]



theorem modular_slash_T_apply : (f ∣[k] T) z = f ((1 : ℝ) +ᵥ z) := by
  rw [SL_slash_apply, denom, UpperHalfPlane.modular_T_smul]
  simp [T]

end slash_action

section slashaction_generators

/- This part proves that SL(2, ℤ) and Γ 2 are generated by {S, T, -I} and {α, β, -I} resp. -/

theorem SL2Z_generate : (⊤ : Subgroup SL(2, ℤ)) = Subgroup.closure {S, T} := by
  exact Eq.symm SpecialLinearGroup.SL2Z_generators

theorem Γ2_generate : (⊤ : Subgroup (Γ 2)) = Subgroup.closure {α, β, negI} := by
  ext ⟨x, hx_det⟩
  simp only [Subgroup.mem_top, Set.mem_univ, SetLike.mem_coe, true_iff]
  -- now prove that all 2x2 matrices with det 1 and equivalent to I modulo 2
  -- is in closure of α, β, and -I
  sorry

/-- If `G` is generated by a set `s`, then the slash action by elements in G is
uniquely determined by the slash action by elements in s. See `slashaction_generators'` for a
version where `s` is a set of elements in `G`. -/
theorem slashaction_generators
    (f : ℍ → ℂ) (G : Subgroup SL(2, ℤ)) (s : Set SL(2, ℤ)) (hG : G = Subgroup.closure s) (k : ℤ) :
    (∀ γ : G, f ∣[k] γ.1 = f) ↔ (∀ γ ∈ s, f ∣[k] γ = f) := by
  subst hG
  constructor <;> intro h
  · intro γ hγ
    convert h ⟨γ, Subgroup.subset_closure hγ⟩
  · simp only [Subtype.forall]
    intro ⟨γ, hγ⟩
    -- key idea: this lemma allows induction on the "words" of the group
    apply Subgroup.closure_induction (G := SL(2, ℤ)) (p := fun γ _ ↦ f ∣[k] γ = f) h --hγ h
    · exact SlashAction.slash_one _ _
    · intro _ _ _ _ hf₁ hf₂
      rw [SlashAction.slash_mul, hf₁, hf₂]
    · intro x _ hf
      rw [← hf, ← SlashAction.slash_mul, mul_inv_cancel, SlashAction.slash_one, hf]

/-- If `G` is generated by a set `s`, then the slash action by elements in G is
uniquely determined by the slash action by elements in s. See `slashaction_generators` for a
version where `s` is a set of elements in SL(2, ℤ). -/
theorem slashaction_generators'
    (f : ℍ → ℂ) {G : Subgroup SL(2, ℤ)} (s : Set G) (hG : ⊤ = Subgroup.closure s) (k : ℤ) :
    (∀ γ : G, f ∣[k] γ.1 = f) ↔ (∀ γ ∈ s, f ∣[k] γ.1 = f) := by
  constructor <;> intro h
  · intro γ _
    exact h _
  · intro ⟨γ, hγ⟩
    -- key idea: this lemma allows induction on the "words" of the group
    apply Subgroup.closure_induction (G := G) (p := fun γ _ ↦ f ∣[k] γ.1 = f) (k := s) ?_ ?_
    · intro _ _ _ _ hf₁ hf₂
      rw [@Subgroup.coe_mul]
      rw [SlashAction.slash_mul, hf₁, hf₂]
    · intro x _ hf
      rw [← hf, ← SlashAction.slash_mul]
      simp [hf]
    · simp [← hG]
    · intro γ hγ
      exact h γ hγ
    · exact SlashAction.slash_one k f

theorem slashaction_generators_SL2Z
    (f : ℍ → ℂ) (k : ℤ) (hS : f ∣[k] S = f) (hT : f ∣[k] T = f) :
    (∀ γ : SL(2, ℤ), f ∣[k] γ = f) := by
  intro γ
  refine (slashaction_generators f ⊤ _ SL2Z_generate k).mpr ?_ ⟨γ, by simp⟩
  intro γ hγ
  rcases hγ with (rfl | rfl | rfl | _) <;> assumption

theorem slashaction_generators_Γ2
    (f : ℍ → ℂ) (k : ℤ) (hα : f ∣[k] α.1 = f) (hβ : f ∣[k] β.1 = f) (hnegI : f ∣[k] negI.1 = f) :
    (∀ γ ∈ Γ 2, f ∣[k] γ = f) := by
  intro γ hγ
  refine (slashaction_generators' f {α, β, negI} Γ2_generate k).mpr ?_ ⟨_, hγ⟩
  intro γ hγ
  rcases hγ with (rfl | rfl | rfl | _) <;> assumption

end slashaction_generators
